input {
  # TCP input for application logs
  tcp {
    port => 5000
    codec => json
    type => "application"
  }

  # File input for system logs
  file {
    path => "/app/logs/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => json
    type => "system"
  }

  # Beat input for metrics
  beats {
    port => 5044
    type => "metrics"
  }

  # HTTP input for custom events
  http {
    port => 8080
    codec => json
    type => "events"
  }
}

filter {
  # Common processing for all logs
  mutate {
    add_field => {
      "environment" => "${ENVIRONMENT:development}"
      "@timestamp" => "%{[timestamp]}"
    }
    remove_field => ["timestamp"]
  }

  # Application log processing
  if [type] == "application" {
    grok {
      match => {
        "message" => "%{LOGLEVEL:log_level} %{TIMESTAMP_ISO8601:timestamp} %{GREEDYDATA:message}"
      }
    }
    
    # Parse JSON in message field if present
    json {
      source => "message"
      target => "parsed_message"
      skip_on_invalid_json => true
    }

    # Add tags based on log level
    if [log_level] == "ERROR" {
      mutate {
        add_tag => ["error"]
      }
    } else if [log_level] == "WARN" {
      mutate {
        add_tag => ["warning"]
      }
    }
  }

  # System log processing
  if [type] == "system" {
    grok {
      match => {
        "message" => "%{SYSLOGLINE}"
      }
    }
    
    # Extract metrics if present
    if [message] =~ "metric:" {
      grok {
        match => {
          "message" => "metric:%{WORD:metric_name}=%{NUMBER:metric_value:float}"
        }
      }
    }
  }

  # Metrics processing
  if [type] == "metrics" {
    # Convert string values to appropriate types
    mutate {
      convert => {
        "value" => "float"
        "count" => "integer"
        "duration" => "float"
      }
    }
    
    # Add aggregation period
    if [metric_type] == "counter" {
      mutate {
        add_field => {
          "aggregation_period" => "5m"
        }
      }
    }
  }

  # Event processing
  if [type] == "events" {
    # Parse event details
    json {
      source => "details"
      target => "event_details"
      skip_on_invalid_json => true
    }
    
    # Add event category based on name
    if [event_name] =~ /error|exception|failure/ {
      mutate {
        add_field => {
          "event_category" => "error"
        }
      }
    } else if [event_name] =~ /warning|alert/ {
      mutate {
        add_field => {
          "event_category" => "warning"
        }
      }
    } else {
      mutate {
        add_field => {
          "event_category" => "info"
        }
      }
    }
  }

  # Add host information
  mutate {
    add_field => {
      "host" => "${HOSTNAME}"
    }
  }

  # Date handling
  date {
    match => ["timestamp", "ISO8601"]
    target => "@timestamp"
    remove_field => ["timestamp"]
  }
}

output {
  # Output to Elasticsearch
  elasticsearch {
    hosts => ["${ELASTICSEARCH_HOST}"]
    index => "ai_data_science_logs-%{+YYYY.MM.dd}"
    template_name => "ai_data_science_logs"
    template_overwrite => true
    
    # Index settings based on log type
    if [type] == "application" {
      index => "ai_data_science_logs-application-%{+YYYY.MM.dd}"
    } else if [type] == "system" {
      index => "ai_data_science_logs-system-%{+YYYY.MM.dd}"
    } else if [type] == "metrics" {
      index => "ai_data_science_logs-metrics-%{+YYYY.MM.dd}"
    } else if [type] == "events" {
      index => "ai_data_science_logs-events-%{+YYYY.MM.dd}"
    }
  }

  # Output to local file for backup
  file {
    path => "/app/logs/processed/%{type}-%{+YYYY-MM-dd}.log"
    codec => json_lines
  }

  # Output error logs to separate file
  if "error" in [tags] {
    file {
      path => "/app/logs/errors/%{+YYYY-MM-dd}-errors.log"
      codec => json_lines
    }
  }

  # Output metrics to Prometheus pushgateway
  if [type] == "metrics" {
    http {
      url => "${PROMETHEUS_PUSHGATEWAY}/metrics/job/ai_data_science_team"
      http_method => "post"
      format => "message"
      message => "%{metric_name}{type=\"%{metric_type}\"} %{metric_value}"
    }
  }

  # Debug output (disabled in production)
  if "${ENVIRONMENT}" == "development" {
    stdout {
      codec => rubydebug
    }
  }
}
